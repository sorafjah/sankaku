<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <!-- モバイルデバイスでの表示とタッチ操作を最適化 --><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>三角形描画アプリ</title>
    <!-- Tailwind CSSを読み込み --><script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Interフォントの読み込み（Tailwindのデフォルト用） */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            /* iOSでのオーバースクロール（バウンス）を無効化 */
            overscroll-behavior: none;
        }
        canvas {
            /* タッチ操作をJavaScriptでハンドルするため、
               ブラウザのデフォルトのタッチ動作（スクロールなど）を無効化します。
            */
            touch-action: none;
            cursor: pointer;
        }
        /* アクティブなボタンのスタイル */
        .tab-btn.active {
            background-color: #2563EB; /* blue-600 */
            color: white;
        }
        /* スクロールバーを細くする（対応ブラウザのみ） */
        #tabs::-webkit-scrollbar {
            height: 4px;
        }
        #tabs::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* gray-300 */
            border-radius: 2px;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <!-- メインコンテナ --><div class="w-full max-w-lg bg-white rounded-xl shadow-2xl overflow-hidden">

        <!-- 1. 描画エリア --><div class="canvas-container w-full aspect-[3/2] bg-white">
            <canvas id="drawingCanvas"></canvas>
        </div>

        <!-- 回転スライダー --><div class="p-4 bg-gray-50 border-b border-t border-gray-200 flex items-center">
            <label for="rotationSlider" class="text-sm font-medium text-gray-700 mr-4 whitespace-nowrap">回転</label>
            <input 
                type="range" 
                id="rotationSlider" 
                min="0" 
                max="360" 
                value="180" 
                class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
            >
        </div>

        <!-- 3. 三角形選択タブ --><div id="tabs" class="flex justify-around p-2 bg-gray-200 border-t border-gray-300 overflow-x-auto" style="padding-bottom: 0.75rem;">
            <button class="tab-btn free px-3 py-2 rounded-lg font-medium text-xs sm:text-sm text-gray-700 transition-all duration-200 active whitespace-nowrap" data-type="free">三角形</button>
            <button class="tab-btn right-angle px-3 py-2 rounded-lg font-medium text-xs sm:text-sm text-gray-700 transition-all duration-200 whitespace-nowrap" data-type="right-angle">直角三角形</button>
            <button class="tab-btn isosceles px-3 py-2 rounded-lg font-medium text-xs sm:text-sm text-gray-700 transition-all duration-200 whitespace-nowrap" data-type="isosceles">二等辺三角形</button>
            <button class="tab-btn right-isosceles px-3 py-2 rounded-lg font-medium text-xs sm:text-sm text-gray-700 transition-all duration-200 whitespace-nowrap" data-type="right-isosceles">直角二等辺三角形</button>
            <button class="tab-btn equilateral px-3 py-2 rounded-lg font-medium text-xs sm:text-sm text-gray-700 transition-all duration-200 whitespace-nowrap" data-type="equilateral">正三角形</button>
        </div>

    </div>

    <script type="module">
        // --- 要素の取得 ---
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('rotationSlider');
        const tabsContainer = document.getElementById('tabs');

        // --- 状態変数 ---
        let vertices = []; // 三角形の頂点座標
        let rotation = 0; // 回転角度 (度)
        let center = { x: 0, y: 0 }; // 回転と移動の中心
        let currentTriangleType = 'free';

        // ドラッグ操作に関する状態
        let selectedVertexIndex = -1;
        let isDraggingShape = false;
        let dragStartPos = { x: 0, y: 0 };
        
        // 頂点ハンドルの半径 (当たり判定用)
        const handleRadius = 15;

        // --- 初期化 ---
        function initialize() {
            const container = canvas.parentElement;
            if (canvas.width !== container.offsetWidth || canvas.height !== container.offsetHeight) {
                canvas.width = container.offsetWidth;
                canvas.height = container.offsetHeight;
            }

            // ★ ページ読み込み時のスライダーの値 (180) から初期回転 (0) を計算
            rotation = parseInt(slider.value, 10) - 180;

            const activeTab = tabsContainer.querySelector('.tab-btn.active');
            const type = activeTab ? activeTab.dataset.type : 'free';
            
            // initTriangle で rotation = 0, slider.value = 180 が設定される
            initTriangle(type); 
            
            setupEventListeners();
        }
        
        // --- イベントリスナー設定 ---
        function setupEventListeners() {
            // 既存のリスナーを削除 (リサイズ時の重複登録を防ぐ)
            tabsContainer.removeEventListener('click', handleTabClick);
            slider.removeEventListener('input', handleSliderInput);
            canvas.removeEventListener('touchstart', handleTouchStart);
            canvas.removeEventListener('touchmove', handleTouchMove);
            canvas.removeEventListener('touchend', handleTouchEnd);
            canvas.removeEventListener('mousedown', handleMouseDown);
            canvas.removeEventListener('mousemove', handleMouseMove);
            canvas.removeEventListener('mouseup', handleMouseUp);
            canvas.removeEventListener('mouseout', handleMouseUp);
            window.removeEventListener('resize', handleResize);

            // リスナーを登録
            tabsContainer.addEventListener('click', handleTabClick);
            slider.addEventListener('input', handleSliderInput);
            // passive: false を指定して、タッチイベントのデフォルト動作（スクロール）を明示的に防ぐ
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseout', handleMouseUp);
            window.addEventListener('resize', handleResize);
        }
        
        // --- イベントハンドラ ---
        function handleTabClick(e) {
            if (e.target.classList.contains('tab-btn')) {
                tabsContainer.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                initTriangle(e.target.dataset.type);
            }
        }
        
        function handleSliderInput(e) {
            // ★★★ 修正: スライダーの値 (0-360) を 回転角度 (-180 - +180) にマッピング
            // 180 (中央) を 0度 とする
            rotation = parseInt(e.target.value) - 180;
            draw();
        }
        
        function handleResize() {
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = container.offsetHeight;
            
            const activeTab = tabsContainer.querySelector('.tab-btn.active');
            const type = activeTab ? activeTab.dataset.type : 'free';
            initTriangle(type);
        }

        // --- 三角形の初期化 ---
        function initTriangle(type) {
            currentTriangleType = type;
            const w = canvas.width;
            const h = canvas.height;
            const size = Math.min(w, h) * 0.4;
            const midX = w / 2;
            const midY = h / 2;

            switch (type) {
                case 'equilateral': // 正三角形
                    const height = size * Math.sqrt(3) / 2;
                    const apexY = midY - (height * 2 / 3);
                    const baseY = midY + (height * 1 / 3);
                    vertices = [
                        { x: midX, y: apexY },
                        { x: midX - size / 2, y: baseY },
                        { x: midX + size / 2, y: baseY }
                    ];
                    break;
                case 'right-angle': // 直角三角形
                    vertices = [
                        { x: midX - size / 2, y: midY - size / 2 },
                        { x: midX - size / 2, y: midY + size / 2 },
                        { x: midX + size / 2, y: midY + size / 2 }
                    ];
                    break;
                case 'isosceles': // 二等辺三角形
                    vertices = [
                        { x: midX, y: midY - size / 2 },
                        { x: midX - size / 1.5, y: midY + size / 2 },
                        { x: midX + size / 1.5, y: midY + size / 2 }
                    ];
                    break;
                case 'right-isosceles': // 直角二等辺三角形
                    vertices = [
                        { x: midX - size / 2, y: midY + size / 2 }, // A (直角, 頂点0) [Bottom-Left]
                        { x: midX + size / 2, y: midY + size / 2 }, // B (頂点1) [Bottom-Right]
                        { x: midX - size / 2, y: midY - size / 2 }  // C (頂点2) [Top-Left]
                    ];
                    break;
                case 'free': // 自由な三角形
                default:
                    vertices = [
                        { x: midX, y: midY - size / 2 },
                        { x: midX - size / 1.5, y: midY + size / 2 },
                        { x: midX + size / 2, y: midY + size / 1.5 }
                    ];
                    break;
            }
            
            // ★★★ 修正:
            // 描画のデフォルト (rotation) は 0度（水平）
            rotation = 0;
            // スライダーのデフォルト (slider.value) は 180度（中央）
            slider.value = 180; 
            
            calculateCenter();
            draw();
        }

        // --- 描画関数 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            calculateCenter();

            ctx.save();
            ctx.translate(center.x, center.y);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.translate(-center.x, -center.y);

            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(vertices[2].x, vertices[2].y);
            ctx.closePath();
            
            ctx.fillStyle = 'rgba(37, 99, 235, 0.7)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(29, 78, 216, 1)';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        // (drawHandles は空なので省略)

        // --- タッチ/マウス ハンドラ ---
        function handleTouchStart(e) {
            e.preventDefault();
            const pos = getTouchPos(e);
            handleInteractionStart(pos);
        }

        function handleMouseDown(e) {
            const pos = getMousePos(e);
            handleInteractionStart(pos);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 0) return;
            const pos = getTouchPos(e);
            handleInteractionMove(pos);
        }

        function handleMouseMove(e) {
            if (!isDraggingShape && selectedVertexIndex === -1) return;
            const pos = getMousePos(e);
            handleInteractionMove(pos);
        }

        function handleTouchEnd(e) {
            handleInteractionEnd();
        }

        function handleMouseUp(e) {
            handleInteractionEnd();
        }
        
        function handleInteractionEnd() {
            selectedVertexIndex = -1;
            isDraggingShape = false;
        }

        // --- 共通操作ロジック ---
        function handleInteractionStart(pos) {
            const rotatedVertices = getRotatedVertices();
            selectedVertexIndex = getVertexAtPos(pos, rotatedVertices);

            if (selectedVertexIndex !== -1) {
                isDraggingShape = false;
                dragStartPos = pos;
            } else {
                if (isPointInTriangle(pos, rotatedVertices)) {
                    isDraggingShape = true;
                    dragStartPos = pos;
                }
            }
        }
        
        function handleInteractionMove(pos) {
            if (selectedVertexIndex !== -1) {
                
                // 1. ドラッグ座標を「回転前の」座標系に変換
                const rad = -rotation * Math.PI / 180;
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                
                const relX = pos.x - center.x;
                const relY = pos.y - center.y;
                const rotatedX = relX * cos - relY * sin;
                const rotatedY = relX * sin + relY * cos;
                const unrotatedPos = {
                    x: rotatedX + center.x,
                    y: rotatedY + center.y
                };

                // 2. 三角形のタイプに応じて変形
                if (currentTriangleType === 'free') {
                    vertices[selectedVertexIndex].x = unrotatedPos.x;
                    vertices[selectedVertexIndex].y = unrotatedPos.y;
                
                } else if (currentTriangleType === 'right-angle') {
                    const A = vertices[0];
                    const B = vertices[1];
                    const C = vertices[2];

                    if (selectedVertexIndex === 0) { // Dragging A
                        const vBC = { x: C.x - B.x, y: C.y - B.y };
                        const vPerp = { x: -vBC.y, y: vBC.x };
                        const vDrag = { x: unrotatedPos.x - B.x, y: unrotatedPos.y - B.y };
                        const dot = vDrag.x * vPerp.x + vDrag.y * vPerp.y;
                        const lenSq = vPerp.x * vPerp.x + vPerp.y * vPerp.y;
                        if (lenSq > 0.0001) {
                            const scale = dot / lenSq;
                            const projVec = { x: vPerp.x * scale, y: vPerp.y * scale };
                            A.x = B.x + projVec.x;
                            A.y = B.y + projVec.y;
                        }
                    } else if (selectedVertexIndex === 2) { // Dragging C
                        const vAB = { x: A.x - B.x, y: A.y - B.y };
                        const vPerp = { x: -vAB.y, y: vAB.x };
                        const vDrag = { x: unrotatedPos.x - B.x, y: unrotatedPos.y - B.y };
                        const dot = vDrag.x * vPerp.x + vDrag.y * vPerp.y;
                        const lenSq = vPerp.x * vPerp.x + vPerp.y * vPerp.y;
                        if (lenSq > 0.0001) {
                            const scale = dot / lenSq;
                            const projVec = { x: vPerp.x * scale, y: vPerp.y * scale };
                            C.x = B.x + projVec.x;
                            C.y = B.y + projVec.y;
                        }
                    } else if (selectedVertexIndex === 1) { // Dragging B (right angle)
                        const dx = unrotatedPos.x - B.x;
                        const dy = unrotatedPos.y - B.y;
                        A.x += dx; A.y += dy;
                        B.x += dx; B.y += dy;
                        C.x += dx; C.y += dy;
                    }

                } else if (currentTriangleType === 'isosceles') {
                    const A = vertices[0];
                    const B = vertices[1];
                    const C = vertices[2];
                    
                    if (selectedVertexIndex === 0) { // Dragging A (apex)
                        const M = { x: (B.x + C.x) / 2, y: (B.y + C.y) / 2 };
                        const vAxis = { x: A.x - M.x, y: A.y - M.y };
                        const vDrag = { x: unrotatedPos.x - M.x, y: unrotatedPos.y - M.y };
                        const dot = vDrag.x * vAxis.x + vDrag.y * vAxis.y;
                        const lenSq = vAxis.x * vAxis.x + vAxis.y * vAxis.y;
                        if (lenSq > 0.0001) {
                            const scale = dot / lenSq;
                            const projVec = { x: vAxis.x * scale, y: vAxis.y * scale };
                            A.x = M.x + projVec.x;
                            A.y = M.y + projVec.y;
                        }
                    } else { // Dragging B or C (base)
                        const M = { x: (B.x + C.x) / 2, y: (B.y + C.y) / 2 };
                        const vAxis = { x: A.x - M.x, y: A.y - M.y };
                        const lenSq = vAxis.x * vAxis.x + vAxis.y * vAxis.y;

                        if (lenSq > 0.0001) {
                            const len = Math.sqrt(lenSq);
                            const n = { x: vAxis.x / len, y: vAxis.y / len };

                            if (selectedVertexIndex === 1) { // Dragging B
                                B.x = unrotatedPos.x;
                                B.y = unrotatedPos.y;
                                const v = { x: B.x - A.x, y: B.y - A.y };
                                const dot = v.x * n.x + v.y * n.y;
                                const v_proj = { x: n.x * dot, y: n.y * dot };
                                const v_perp = { x: v.x - v_proj.x, y: v.y - v_proj.y };
                                const vAC_new = { x: v_proj.x - v_perp.x, y: v_proj.y - v_perp.y };
                                C.x = A.x + vAC_new.x;
                                C.y = A.y + vAC_new.y;
                            } else if (selectedVertexIndex === 2) { // Dragging C
                                C.x = unrotatedPos.x;
                                C.y = unrotatedPos.y;
                                const v = { x: C.x - A.x, y: C.y - A.y };
                                const dot = v.x * n.x + v.y * n.y;
                                const v_proj = { x: n.x * dot, y: n.y * dot };
                                const v_perp = { x: v.x - v_proj.x, y: v.y - v_proj.y };
                                const vAB_new = { x: v_proj.x - v_perp.x, y: v_proj.y - v_perp.y };
                                B.x = A.x + vAB_new.x;
                                B.y = A.y + vAB_new.y;
                            }
                        }
                    }

                } else if (currentTriangleType === 'right-isosceles') {
                    const A = vertices[0];
                    const B = vertices[1];
                    const C = vertices[2];

                    if (selectedVertexIndex === 0) { // Dragging A (right angle)
                        const dx = unrotatedPos.x - A.x;
                        const dy = unrotatedPos.y - A.y;
                        A.x += dx; A.y += dy;
                        B.x += dx; B.y += dy;
                        C.x += dx; C.y += dy;
                    } else if (selectedVertexIndex === 1) { // Dragging B
                        const vAB_orig = { x: B.x - A.x, y: B.y - A.y };
                        const vDrag = { x: unrotatedPos.x - A.x, y: unrotatedPos.y - A.y };
                        const dot = vDrag.x * vAB_orig.x + vDrag.y * vAB_orig.y;
                        const lenSq = vAB_orig.x * vAB_orig.x + vAB_orig.y * vAB_orig.y;
                        if (lenSq > 0.0001) {
                            const scale = dot / lenSq;
                            const vAB_new = { x: vAB_orig.x * scale, y: vAB_orig.y * scale };
                            B.x = A.x + vAB_new.x;
                            B.y = A.y + vAB_new.y;
                            const vAC_new = { x: vAB_new.y, y: -vAB_new.x };
                            C.x = A.x + vAC_new.x;
                            C.y = A.y + vAC_new.y;
                        }
                    } else if (selectedVertexIndex === 2) { // Dragging C
                        const vAC_orig = { x: C.x - A.x, y: C.y - A.y };
                        const vDrag = { x: unrotatedPos.x - A.x, y: unrotatedPos.y - A.y };
                        const dot = vDrag.x * vAC_orig.x + vDrag.y * vAC_orig.y;
                        const lenSq = vAC_orig.x * vAC_orig.x + vAC_orig.y * vAC_orig.y;
                        if (lenSq > 0.0001) {
                            const scale = dot / lenSq;
                            const vAC_new = { x: vAC_orig.x * scale, y: vAC_orig.y * scale };
                            C.x = A.x + vAC_new.x;
                            C.y = A.y + vAC_new.y;
                            const vAB_new = { x: -vAC_new.y, y: vAC_new.x };
                            B.x = A.x + vAB_new.x;
                            B.y = A.y + vAB_new.y;
                        }
                    }

                } else {
                    // 拡大・縮小ロジック (equilateralなど)
                    const scale = calculateScale(pos);
                    applyScale(scale);
                    dragStartPos = pos;
                }
                
                draw();

            } else if (isDraggingShape) {
                // 図形全体の移動
                const dx = pos.x - dragStartPos.x;
                const dy = pos.y - dragStartPos.y;
                vertices.forEach(v => {
                    v.x += dx;
                    v.y += dy;
                });
                dragStartPos = pos;
                draw();
            }
        }

        // --- ヘルパー関数 (拡大・縮小用) ---
        function calculateScale(pos) {
            const currentCenter = { x: center.x, y: center.y };
            const startDist = Math.sqrt(Math.pow(dragStartPos.x - currentCenter.x, 2) + Math.pow(dragStartPos.y - currentCenter.y, 2));
            const currentDist = Math.sqrt(Math.pow(pos.x - currentCenter.x, 2) + Math.pow(pos.y - currentCenter.y, 2));
            if (startDist < 1) return 1;
            return currentDist / startDist;
        }

        function applyScale(scale) {
            const currentCenter = { x: center.x, y: center.y };
            vertices.forEach(v => {
                const relX = v.x - currentCenter.x;
                const relY = v.y - currentCenter.y;
                v.x = currentCenter.x + relX * scale;
                v.y = currentCenter.y + relY * scale;
            });
        }

D
        // --- 座標・当たり判定 ユーティリティ ---
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.touches[0].clientX - rect.left) * scaleX,
                y: (e.touches[0].clientY - rect.top) * scaleY
            };
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function calculateCenter() {
            center.x = (vertices[0].x + vertices[1].x + vertices[2].x) / 3;
            center.y = (vertices[0].y + vertices[1].y + vertices[2].y) / 3;
        }

        function getRotatedVertices() {
            const rad = rotation * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            return vertices.map(v => {
                const relX = v.x - center.x;
                const relY = v.y - center.y;
                const rotatedX = relX * cos - relY * sin;
                const rotatedY = relX * sin + relY * cos;
                return {
                    x: rotatedX + center.x,
                    y: rotatedY + center.y
                };
            });
        }

        function getVertexAtPos(pos, vertexList) {
            for (let i = 0; i < vertexList.length; i++) {
                const v = vertexList[i];
                const dx = pos.x - v.x;
                const dy = pos.y - v.y;
                if (dx * dx + dy * dy < handleRadius * handleRadius) {
                    return i; 
                }
            }
            return -1;
        }

        function isPointInTriangle(pos, triVertices) {
            const [v0, v1, v2] = triVertices;
            const c1 = (v1.x - v0.x) * (pos.y - v0.y) - (v1.y - v0.y) * (pos.x - v0.x);
            const c2 = (v2.x - v1.x) * (pos.y - v1.y) - (v2.y - v1.y) * (pos.x - v1.x);
            const c3 = (v0.x - v2.x) * (pos.y - v2.y) - (v0.y - v2.y) * (pos.x - v2.x);
            return (c1 >= 0 && c2 >= 0 && c3 >= 0) || (c1 <= 0 && c2 <= 0 && c3 <= 0);
        }

        // --- アプリケーションの開始 ---
        document.addEventListener('DOMContentLoaded', () => {
            initialize();
        });

    </script>
</body>
</html>

